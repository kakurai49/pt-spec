<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR â†’ CSV (G:(W,E)â†’(S,A(S)) ãƒ‡ãƒ¢)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; margin: 0; padding: 0; background: #fafafa; color: #111; }
    header { padding: 16px 20px; background: #111; color: #fff; }
    header h1 { margin: 0; font-size: 18px; }
    main { padding: 16px 20px; display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 16px; align-items: start; }
    section { background: #fff; border: 1px solid #ddd; border-radius: 10px; padding: 14px; }
    section h2 { margin: 0 0 10px; font-size: 16px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    .row > * { flex: 0 0 auto; }
    .muted { color: #666; font-size: 12px; line-height: 1.4; }
    button { padding: 8px 12px; border-radius: 8px; border: 1px solid #aaa; background: #f6f6f6; cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    input[type="file"] { padding: 6px; border: 1px solid #ccc; border-radius: 8px; }
    label { font-size: 13px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    pre { background: #0b1020; color: #dbe7ff; padding: 10px; border-radius: 10px; overflow: auto; max-height: 280px; font-size: 12px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 6px; vertical-align: top; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    td.code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 11px; }
    .ok { background: #f0fff2; }
    .warn { background: #fff6e5; }
    .err { background: #fff0f0; }
    video, canvas { width: 100%; border-radius: 10px; border: 1px solid #ddd; background: #000; }
    .small { font-size: 11px; }
    footer { padding: 14px 20px; color: #666; font-size: 12px; }
/* ===== Responsive patch (ã‚¹ãƒãƒ›å¯¾å¿œ) ===== */

/* 2ã‚«ãƒ©ãƒ æ™‚ã«æ¨ªã¯ã¿å‡ºã—ã‚’èµ·ã“ã—ã«ããã™ã‚‹ */
section { min-width: 0; }
main { grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr); }

/* ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆä»¥ä¸‹: 2ã‚«ãƒ©ãƒ  â†’ 1ã‚«ãƒ©ãƒ ã« */
@media (max-width: 960px) {
  main { grid-template-columns: 1fr; }

  /* æœ«å°¾ã® <section style="grid-column: 1 / span 2;"> ãŒ
     1ã‚«ãƒ©ãƒ æ™‚ã«â€œæš—é»™ã®2åˆ—â€ã‚’ä½œã£ã¦æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«ãªã‚‹ã®ã‚’é˜²ã */
  section[style*="grid-column"] { grid-column: 1 / -1 !important; }
}

/* ã‚¹ãƒãƒ›: å…¥åŠ›è¡Œã‚„2åˆ†å‰²ã‚’ç¸¦ç©ã¿ã« */
@media (max-width: 640px) {
  header { padding: 12px 14px; }
  header h1 { font-size: 16px; line-height: 1.3; }

  main { padding: 12px 14px; gap: 12px; }
  section { padding: 12px; }

  /* 2åˆ†å‰²UIã‚’1åˆ—ã« */
  .grid2 { grid-template-columns: 1fr; }

  /* ãƒœã‚¿ãƒ³ç¾¤ã‚„ãƒã‚§ãƒƒã‚¯ç¾¤ã‚’ç¸¦ç©ã¿ã«ï¼ˆæŠ¼ã—ã‚„ã™ãï¼‰ */
  .row { flex-direction: column; align-items: stretch; }
  .row > * { width: 100%; }

  button, input[type="file"] { width: 100%; }

  /* ãƒ­ã‚°æ ãŒå¤§ãã™ãã‚‹å ´åˆã¯å°‘ã—æŠ‘ãˆã‚‹ */
  pre { max-height: 220px; }
}

  </style>
  <!-- Fallback QR decoder (single QR). If your environment has no internet, download jsQR and serve it locally. -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
</head>
<body>
<header>
  <h1>QR â†’ CSV (G:(W,E)â†’(S,A(S)) ã®ã€Œå‹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆè¨­è¨ˆã€ã‚µãƒ³ãƒ—ãƒ« / Browser JavaScript)</h1>
</header>

<main>
  <section>
    <h2>å…¥åŠ›</h2>

    <div class="grid2">
      <div>
        <label><strong>ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«</strong>ï¼ˆè¤‡æ•°OKï¼‰</label><br/>
        <input id="fileInput" type="file" accept="image/*" multiple />
        <div class="muted">ç”»åƒ1æšãšã¤èª­ã¿å–ã‚Šã€çµæœã‚’è¡¨ã«è¿½åŠ ã—ã¾ã™ã€‚</div>
      </div>
      <div>
        <label><strong>ç”»åƒãƒ•ã‚©ãƒ«ãƒ€</strong>ï¼ˆChromeç³»: webkitdirectoryï¼‰</label><br/>
        <input id="dirInput" type="file" accept="image/*" webkitdirectory multiple />
        <div class="muted" id="dirSupportMessage">ãƒ•ã‚©ãƒ«ãƒ€é…ä¸‹ã®ç”»åƒã‚’ã¾ã¨ã‚ã¦å‡¦ç†ã—ã¾ã™ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ä¾å­˜ï¼‰ã€‚</div>
      </div>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:12px 0;"/>

    <div class="row">
      <button id="startCam" class="primary" type="button">ğŸ“· ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
      <button id="stopCam" disabled type="button">â¹ åœæ­¢</button>
      <label class="small"><input type="checkbox" id="dedup" checked /> é‡è¤‡æŠ‘åˆ¶ï¼ˆåŒã˜payloadã¯è¿½åŠ ã—ãªã„ï¼‰</label>
      <label class="small"><input type="checkbox" id="recordNoQr" /> ï¼ˆç”»åƒã®ã¿ï¼‰QRç„¡ã—ã‚‚è¨˜éŒ²ã™ã‚‹</label>
    </div>

    <div class="row">
      <button id="exportCsv" class="primary" type="button">â¬‡ CSVã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
      <button id="clear" type="button">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
      <span class="muted">â€» ã‚«ãƒ¡ãƒ©ã¯ <strong>https</strong> ã¾ãŸã¯ <strong>localhost</strong> ã§ãªã„ã¨èµ·å‹•ã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</span>
    </div>

    <div class="grid2">
      <div>
        <h3 style="margin: 8px 0 6px; font-size: 14px;">ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
        <video id="video" playsinline muted></video>
        <canvas id="canvas" style="display:none;"></canvas>
      </div>
      <div>
        <h3 style="margin: 8px 0 6px; font-size: 14px;">ãƒ­ã‚°</h3>
        <pre id="log"></pre>
      </div>
    </div>
  </section>

  <section>
    <h2>ä¸­é–“ç”Ÿæˆç‰© (S ã¨ A(S))</h2>
    <div class="muted">
      è«–æ–‡ã®å†™åƒ <code>G:(W,E)â†’(S,A(S))</code> ã«å¯¾å¿œã—ã¦ã€ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯
      <strong>S = (å…¥åŠ›ç¨®åˆ¥, èª­ã¿å–ã‚Šçµæœ, ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ç¨®åˆ¥, å‡ºåŠ›ãƒ¢ãƒ¼ãƒ‰)</strong> ã‚’æ¡ç”¨ã—ã€
      A(S) ã‚’æœ€å°ä»£è¡¨ã¨ã—ã¦ A1ã€œA5 ã«é›¢æ•£åŒ–ã—ã¦ã„ã¾ã™ã€‚
    </div>

    <div class="row">
      <button id="toggleModel" type="button">ãƒ¢ãƒ‡ãƒ«JSONã‚’è¡¨ç¤º/éè¡¨ç¤º</button>
      <span class="muted">ï¼ˆå®Ÿè£…ãŒæ‰±ã†â€œå‹â€ã¨â€œç­‰ä¾¡ã‚¯ãƒ©ã‚¹â€ã‚’ã“ã“ã§å›ºå®šåŒ–ï¼‰</span>
    </div>
    <pre id="modelJson" style="display:none;"></pre>

    <h3 style="margin: 8px 0 6px; font-size: 14px;">A(S) ã‚«ãƒãƒ¬ãƒƒã‚¸ï¼ˆè¦³æ¸¬ï¼‰</h3>
    <table id="coverageTable">
      <thead>
        <tr>
          <th>A(S)</th>
          <th>æ„å‘³ï¼ˆä»£è¡¨æ¡ä»¶ï¼‰</th>
          <th>ä»¶æ•°</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section style="grid-column: 1 / span 2;">
    <h2>çµæœï¼ˆCSVã«å‡ºã‚‹è¡Œï¼‰</h2>
    <div class="muted">åˆ—ã¯ OutputRecord ã®ã€Œå‹ã€ã¨ã—ã¦å›ºå®šã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ï¼CSVã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‚</div>
    <div style="overflow:auto; max-height: 420px; border: 1px solid #eee; border-radius: 10px; margin-top: 10px;">
      <table id="resultTable">
        <thead>
          <tr>
            <th>æ™‚åˆ»</th>
            <th>å…¥åŠ›</th>
            <th>çµæœ</th>
            <th>payloadç¨®åˆ¥</th>
            <th>payload</th>
            <th>A(S)</th>
            <th>å‚™è€ƒ</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</main>

<footer>
  <div>ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ãƒ¡ãƒ¢ï¼š</div>
  <ul>
    <li>å¯èƒ½ãªã‚‰ <code>BarcodeDetector</code>ï¼ˆè¤‡æ•°QRå¯¾å¿œï¼‰ã‚’ä½¿ç”¨ã€ç„¡ã‘ã‚Œã° <code>jsQR</code>ï¼ˆ1å€‹ã®ã¿ï¼‰ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚</li>
    <li>ã“ã®HTMLã¯å­¦ç¿’ç”¨ã®æœ€å°å®Ÿè£…ã§ã™ã€‚æ¥­å‹™åˆ©ç”¨ã§ã¯ä¾‹å¤–å‡¦ç†ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å¼·åŒ–ã—ã¦ãã ã•ã„ã€‚</li>
  </ul>
</footer>

<script>
/**
 * ============================
 *  0) å‹ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ï¼‰å®šç¾©
 * ============================
 */

/** @enum {string} */
const InputSourceKind = Object.freeze({
  image_file: "image_file",
  image_dir: "image_dir",
  webcam: "webcam",
});

/** @enum {string} */
const DecodeOutcome = Object.freeze({
  no_qr: "no_qr",
  single_qr: "single_qr",
  multi_qr: "multi_qr",
  decode_error: "decode_error",
});

/** @enum {string} */
const PayloadKind = Object.freeze({
  empty: "empty",
  plain_text: "plain_text",
  url: "url",
  json: "json",
  vcard: "vcard",
  wifi: "wifi",
  unknown: "unknown",
});

/** @enum {string} */
const OutputMode = Object.freeze({
  new_file: "new_file",
  append: "append",
});

/**
 * @typedef {Object} Situation
 * @property {string} inputSourceKind  - InputSourceKind
 * @property {string} decodeOutcome    - DecodeOutcome
 * @property {string} payloadKind      - PayloadKind
 * @property {string} outputMode       - OutputMode
 */

/**
 * @typedef {Object} QRDecode
 * @property {string} text
 * @property {Object|null} bbox
 */

/**
 * @typedef {Object} ParsedPayload
 * @property {string} kind
 * @property {string} normalized
 * @property {any|null} jsonValue
 */

/**
 * @typedef {Object} OutputRecord
 * @property {string} timestampISO
 * @property {string} sourceKind
 * @property {string} sourceId
 * @property {string} decodeOutcome
 * @property {string} payloadKind
 * @property {string} payload
 * @property {string} payloadNormalized
 * @property {string} testConditionId
 * @property {string} bboxJson
 * @property {string} error
 */

/**
 * ==========================================
 *  1) è«–æ–‡ãƒ¢ãƒ‡ãƒ« G:(W,E)â†’(S,A(S)) ã®å®Ÿè£…
 * ==========================================
 */

const MODEL = Object.freeze({
  G: "G:(W,E)â†’(S,A(S))",
  W: {
    description: "ä¸–ç•Œï¼ˆé€£ç¶šçš„å¯èƒ½æ€§ï¼‰: ç”»åƒ/ã‚«ãƒ¡ãƒ©å…¥åŠ›ã€QRã®æœ‰ç„¡ãƒ»æ•°ã€QRå†…å®¹ï¼ˆURL/JSON/ãƒ†ã‚­ã‚¹ãƒˆç­‰ï¼‰ã€ä¾‹å¤–ãªã©ã€‚",
  },
  E: {
    description: "åˆ¶ç´„ãƒ»è©•ä¾¡åŸºæº–: åˆå¿ƒè€…ã§ã‚‚æ‰±ãˆã‚‹ã€ä¾å­˜ã‚’å¢—ã‚„ã•ãªã„ã€å‹ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ï¼‰ã‚’å…ˆã«æ±ºã‚ã‚‹ã€ç­‰ã€‚",
  },
  S: {
    definition: "S := (InputSourceKind, DecodeOutcome, PayloadKind, OutputMode)",
    enums: {
      InputSourceKind,
      DecodeOutcome,
      PayloadKind,
      OutputMode,
    },
  },
  A: [
    { id: "A1", name: "ç”»åƒ1æšãƒ»QR1å€‹ãƒ»ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ»æ–°è¦CSV", predicate: "image_file âˆ§ single_qr âˆ§ plain_text âˆ§ new_file" },
    { id: "A2", name: "ãƒ•ã‚©ãƒ«ãƒ€/è¤‡æ•°ãƒ»URLç³»ãƒ»æ–°è¦CSV", predicate: "(image_dir âˆ¨ image_file) âˆ§ (multi_qr âˆ¨ single_qr) âˆ§ url âˆ§ new_file" },
    { id: "A3", name: "QRãŒç„¡ã„", predicate: "(image_file âˆ¨ image_dir) âˆ§ no_qr" },
    { id: "A4", name: "Webã‚«ãƒ¡ãƒ©ãƒ»QR1å€‹ãƒ»JSONãƒ»è¿½è¨˜", predicate: "webcam âˆ§ single_qr âˆ§ json âˆ§ append" },
    { id: "A5", name: "ãƒ‡ã‚³ãƒ¼ãƒ‰ä¾‹å¤–/å…¥åŠ›ä¸è‰¯", predicate: "decode_error" },
  ],
});

/** @param {Situation} s */
function classifyTestCondition(s) {
  const isImage = (s.inputSourceKind === InputSourceKind.image_file || s.inputSourceKind === InputSourceKind.image_dir);
  if (s.decodeOutcome === DecodeOutcome.decode_error) return "A5";
  if (isImage && s.decodeOutcome === DecodeOutcome.no_qr) return "A3";
  if (s.inputSourceKind === InputSourceKind.webcam && s.decodeOutcome === DecodeOutcome.single_qr && s.payloadKind === PayloadKind.json && s.outputMode === OutputMode.append) return "A4";
  if ((s.inputSourceKind === InputSourceKind.image_dir || s.inputSourceKind === InputSourceKind.image_file) && (s.decodeOutcome === DecodeOutcome.multi_qr || s.decodeOutcome === DecodeOutcome.single_qr) && s.payloadKind === PayloadKind.url && s.outputMode === OutputMode.new_file) return "A2";
  if (s.inputSourceKind === InputSourceKind.image_file && s.decodeOutcome === DecodeOutcome.single_qr && s.payloadKind === PayloadKind.plain_text && s.outputMode === OutputMode.new_file) return "A1";
  return "A?";
}

class PayloadParser {
  /** @param {string} text @returns {ParsedPayload} */
  static parse(text) {
    const raw = (text ?? "").trim();
    if (raw.length === 0) return { kind: PayloadKind.empty, normalized: "", jsonValue: null };
    if (/^BEGIN:VCARD/i.test(raw)) return { kind: PayloadKind.vcard, normalized: raw.replace(/\r\n/g, "\n"), jsonValue: null };
    if (/^WIFI:/i.test(raw)) return { kind: PayloadKind.wifi, normalized: raw, jsonValue: null };
    if (/^[\[{]/.test(raw)) {
      try { const v = JSON.parse(raw); return { kind: PayloadKind.json, normalized: JSON.stringify(v), jsonValue: v }; } catch (_) {}
    }
    try {
      const u = new URL(raw);
      if (u.protocol === "http:" || u.protocol === "https:") return { kind: PayloadKind.url, normalized: u.toString(), jsonValue: null };
    } catch (_) {}
    return { kind: PayloadKind.plain_text, normalized: raw, jsonValue: null };
  }
}

class QRDecoder {
  constructor() { this.detector = null; this._initDetector(); }
  _initDetector() {
    try { if ("BarcodeDetector" in window) this.detector = new BarcodeDetector({ formats: ["qr_code"] }); } catch (e) { this.detector = null; }
  }
  /** @param {HTMLCanvasElement} canvas @returns {Promise<QRDecode[]>} */
  async decodeFromCanvas(canvas) {
    if (this.detector) {
      try {
        const barcodes = await this.detector.detect(canvas);
        const out = barcodes.map(b => ({
          text: String(b.rawValue ?? ""),
          bbox: b.boundingBox ? { x: b.boundingBox.x, y: b.boundingBox.y, width: b.boundingBox.width, height: b.boundingBox.height } : null
        }));
        return out.filter(x => x.text.length > 0);
      } catch (e) {}
    }
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) throw new Error("2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã§ãã¾ã›ã‚“");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    if (typeof window.jsQR !== "function") throw new Error("QRãƒ‡ã‚³ãƒ¼ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆBarcodeDetectorã‚‚jsQRã‚‚åˆ©ç”¨ä¸å¯ï¼‰");
    const code = window.jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
    if (!code) return [];
    return [{
      text: String(code.data ?? ""),
      bbox: code.location ? {
        x: code.location.topLeftCorner.x,
        y: code.location.topLeftCorner.y,
        width: (code.location.bottomRightCorner.x - code.location.topLeftCorner.x),
        height: (code.location.bottomRightCorner.y - code.location.topLeftCorner.y),
      } : null,
    }];
  }
}

class CSVWriter {
  /** @param {OutputRecord[]} records @returns {string} */
  static toCSV(records) {
    const cols = ["timestampISO","sourceKind","sourceId","decodeOutcome","payloadKind","payload","payloadNormalized","testConditionId","bboxJson","error"];
    const escapeCsv = (v) => {
      const s = String(v ?? "");
      const needs = /[",\n\r]/.test(s);
      const inner = s.replace(/"/g, '""');
      return needs ? `"${inner}"` : inner;
    };
    const lines = [];
    lines.push(cols.join(","));
    for (const r of records) lines.push(cols.map(c => escapeCsv(r[c])).join(","));
    return "\ufeff" + lines.join("\n"); // Excelå‘ã‘BOM
  }
  /** @param {OutputRecord[]} records */
  static download(records) {
    const csv = CSVWriter.toCSV(records);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const now = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const filename = `qr_export_${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.csv`;
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
}

class QRToCSVUsecase {
  constructor(decoder) { this.decoder = decoder; }

  /** @param {File} file @param {string} sourceKind @param {string} outputMode @returns {Promise<OutputRecord[]>} */
  async processImageFile(file, sourceKind, outputMode) {
    const ts = new Date().toISOString();
    const sourceId = file.webkitRelativePath || file.name || "(unknown)";
    try {
      const img = await this._loadImageFromFile(file);
      const canvas = this._drawToCanvas(img);
      const decodes = await this.decoder.decodeFromCanvas(canvas);
      const outcome =
        decodes.length === 0 ? DecodeOutcome.no_qr :
        decodes.length === 1 ? DecodeOutcome.single_qr :
        DecodeOutcome.multi_qr;

      if (decodes.length === 0) {
        const s = { inputSourceKind: sourceKind, decodeOutcome: outcome, payloadKind: PayloadKind.empty, outputMode };
        return [this._toRecord(ts, sourceKind, sourceId, outcome, "", PayloadKind.empty, "", s, null, "")];
      }

      const rs = [];
      for (const d of decodes) {
        const parsed = PayloadParser.parse(d.text);
        const s = { inputSourceKind: sourceKind, decodeOutcome: outcome, payloadKind: parsed.kind, outputMode };
        rs.push(this._toRecord(ts, sourceKind, sourceId, outcome, d.text, parsed.kind, parsed.normalized, s, d.bbox, ""));
      }
      return rs;
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      const s = { inputSourceKind: sourceKind, decodeOutcome: DecodeOutcome.decode_error, payloadKind: PayloadKind.unknown, outputMode };
      return [this._toRecord(ts, sourceKind, sourceId, DecodeOutcome.decode_error, "", PayloadKind.unknown, "", s, null, msg)];
    }
  }

  /** @param {HTMLCanvasElement} canvas @param {string} sourceId @returns {Promise<OutputRecord[]>} */
  async processWebcamFrame(canvas, sourceId) {
    const ts = new Date().toISOString();
    const sourceKind = InputSourceKind.webcam;
    const outputMode = OutputMode.append;
    try {
      const decodes = await this.decoder.decodeFromCanvas(canvas);
      const outcome =
        decodes.length === 0 ? DecodeOutcome.no_qr :
        decodes.length === 1 ? DecodeOutcome.single_qr :
        DecodeOutcome.multi_qr;
      if (decodes.length === 0) return []; // ã‚«ãƒ¡ãƒ©ã¯ no_qr ã‚’è¨˜éŒ²ã—ãªã„

      const rs = [];
      for (const d of decodes) {
        const parsed = PayloadParser.parse(d.text);
        const s = { inputSourceKind: sourceKind, decodeOutcome: outcome, payloadKind: parsed.kind, outputMode };
        rs.push(this._toRecord(ts, sourceKind, sourceId, outcome, d.text, parsed.kind, parsed.normalized, s, d.bbox, ""));
      }
      return rs;
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      const s = { inputSourceKind: InputSourceKind.webcam, decodeOutcome: DecodeOutcome.decode_error, payloadKind: PayloadKind.unknown, outputMode: OutputMode.append };
      return [this._toRecord(ts, InputSourceKind.webcam, sourceId, DecodeOutcome.decode_error, "", PayloadKind.unknown, "", s, null, msg)];
    }
  }

  _toRecord(timestampISO, sourceKind, sourceId, decodeOutcome, payload, payloadKind, payloadNormalized, situation, bbox, error) {
    const testConditionId = classifyTestCondition(situation);
    return {
      timestampISO, sourceKind, sourceId,
      decodeOutcome, payloadKind, payload,
      payloadNormalized, testConditionId,
      bboxJson: bbox ? JSON.stringify(bbox) : "",
      error: error || "",
    };
  }

  _loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("ç”»åƒã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“: " + (file.name || ""))); };
      img.src = url;
    });
  }

  _drawToCanvas(img) {
    const canvas = document.createElement("canvas");
    const MAX = 1280;
    let w = img.naturalWidth || img.width;
    let h = img.naturalHeight || img.height;
    if (w > MAX || h > MAX) {
      const scale = Math.min(MAX / w, MAX / h);
      w = Math.max(1, Math.floor(w * scale));
      h = Math.max(1, Math.floor(h * scale));
    }
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) throw new Error("2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆã§ãã¾ã›ã‚“");
    ctx.drawImage(img, 0, 0, w, h);
    return canvas;
  }
}

/** UI */
const el = {
  fileInput: document.getElementById("fileInput"),
  dirInput: document.getElementById("dirInput"),
  startCam: document.getElementById("startCam"),
  stopCam: document.getElementById("stopCam"),
  dedup: document.getElementById("dedup"),
  recordNoQr: document.getElementById("recordNoQr"),
  exportCsv: document.getElementById("exportCsv"),
  clear: document.getElementById("clear"),
  video: document.getElementById("video"),
  canvas: document.getElementById("canvas"),
  log: document.getElementById("log"),
  resultTbody: document.querySelector("#resultTable tbody"),
  coverageTbody: document.querySelector("#coverageTable tbody"),
  modelJson: document.getElementById("modelJson"),
  toggleModel: document.getElementById("toggleModel"),
};

const decoder = new QRDecoder();
const usecase = new QRToCSVUsecase(decoder);

let records = [];
let seenPayloadKeys = new Set();
let camStream = null;
let camLoopHandle = null;
let lastScanAt = 0;

function log(msg) {
  const ts = new Date().toISOString().replace("T", " ").replace("Z", "");
  el.log.textContent = `[${ts}] ${msg}\n` + el.log.textContent;
}
function renderModel() { el.modelJson.textContent = JSON.stringify(MODEL, null, 2); }
function renderCoverage() {
  const counts = new Map(); for (const a of MODEL.A) counts.set(a.id, 0); counts.set("A?", 0);
  for (const r of records) counts.set(r.testConditionId, (counts.get(r.testConditionId) || 0) + 1);
  el.coverageTbody.innerHTML = "";
  const rows = [...MODEL.A, { id: "A?", name: "æœªåˆ†é¡ï¼ˆãƒ¢ãƒ‡ãƒ«å¤–ï¼‰", predicate: "ãã®ä»–" }];
  for (const a of rows) {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td class="code">${a.id}</td><td>${a.name}<div class="muted">${a.predicate}</div></td><td>${counts.get(a.id) || 0}</td>`;
    el.coverageTbody.appendChild(tr);
  }
}
function escapeHtml(s) {
  return String(s ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function renderTable() {
  el.resultTbody.innerHTML = "";
  for (const r of records) {
    const tr = document.createElement("tr");
    const pillClass =
      r.decodeOutcome === DecodeOutcome.decode_error ? "pill err" :
      (r.decodeOutcome === DecodeOutcome.no_qr ? "pill warn" : "pill ok");
    const payloadShort = (r.payload || "").length > 120 ? (r.payload.slice(0,120) + "â€¦") : (r.payload || "");
    const note = r.error ? `<span class="pill err">error</span> ${escapeHtml(r.error)}`
                         : (r.bboxJson ? `<span class="pill">bbox</span> <span class="muted">${escapeHtml(r.bboxJson)}</span>` : "");
    tr.innerHTML = `
      <td class="code">${escapeHtml(r.timestampISO)}</td>
      <td><span class="pill">${escapeHtml(r.sourceKind)}</span><div class="muted">${escapeHtml(r.sourceId)}</div></td>
      <td><span class="${pillClass}">${escapeHtml(r.decodeOutcome)}</span></td>
      <td><span class="pill">${escapeHtml(r.payloadKind)}</span></td>
      <td class="code">${escapeHtml(payloadShort)}</td>
      <td class="code">${escapeHtml(r.testConditionId)}</td>
      <td>${note}</td>
    `;
    el.resultTbody.appendChild(tr);
  }
  renderCoverage();
}
function dedupKey(r) { return `${r.payloadKind}::${r.payloadNormalized || r.payload}`; }
function addRecords(newOnes, { allowNoQr } = { allowNoQr: false }) {
  for (const r of newOnes) {
    if (!allowNoQr && r.decodeOutcome === DecodeOutcome.no_qr) continue;
    if (el.dedup.checked && r.decodeOutcome !== DecodeOutcome.no_qr) {
      const key = dedupKey(r);
      if (seenPayloadKeys.has(key)) continue;
      seenPayloadKeys.add(key);
    }
    records.push(r);
  }
  renderTable();
}
async function handleFiles(fileList, sourceKind) {
  const files = Array.from(fileList || []);
  if (files.length === 0) {
    log("ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“");
    return;
  }
  log(`${files.length} ä»¶ã®ç”»åƒã‚’å‡¦ç†ã—ã¾ã™â€¦ (${sourceKind})`);
  for (const f of files) {
    const rs = await usecase.processImageFile(f, sourceKind, OutputMode.new_file);
    const allowNoQr = el.recordNoQr.checked;
    addRecords(rs, { allowNoQr });
    const last = rs[0];
    if (last && last.decodeOutcome === DecodeOutcome.decode_error) log(`âŒ ${f.name}: ${last.error}`);
    else if (last && last.decodeOutcome === DecodeOutcome.no_qr) log(`âš ï¸ ${f.name}: QRãªã—`);
    else log(`âœ… ${f.name}: ${rs.length} ä»¶`);
    await new Promise(res => setTimeout(res, 10));
  }
  log("å®Œäº†");
}
async function startCamera() {
  if (camStream) return;
  try {
    camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
    el.video.srcObject = camStream;
    await el.video.play();
    el.startCam.disabled = true; el.stopCam.disabled = false;
    log("ã‚«ãƒ¡ãƒ©é–‹å§‹");
    camLoop();
  } catch (e) {
    const msg = (e && e.message) ? e.message : String(e);
    log("ã‚«ãƒ¡ãƒ©é–‹å§‹å¤±æ•—: " + msg);
    camStream = null;
  }
}
function stopCamera() {
  if (!camStream) return;
  try { for (const t of camStream.getTracks()) t.stop(); } catch (_) {}
  camStream = null;
  if (camLoopHandle) cancelAnimationFrame(camLoopHandle);
  camLoopHandle = null;
  el.video.srcObject = null;
  el.startCam.disabled = false; el.stopCam.disabled = true;
  log("ã‚«ãƒ¡ãƒ©åœæ­¢");
}
async function camLoop() {
  if (!camStream) return;
  const now = performance.now();
  const intervalMs = 300;
  if (now - lastScanAt >= intervalMs) {
    lastScanAt = now;
    const w = el.video.videoWidth;
    const h = el.video.videoHeight;
    if (w && h) {
      el.canvas.width = w; el.canvas.height = h;
      const ctx = el.canvas.getContext("2d", { willReadFrequently: true });
      if (ctx) {
        ctx.drawImage(el.video, 0, 0, w, h);
        const rs = await usecase.processWebcamFrame(el.canvas, "webcam:0");
        if (rs.length > 0) { addRecords(rs, { allowNoQr: false }); log(`ğŸ“Œ QRæ¤œå‡º: ${rs.map(r => r.payloadKind).join(", ")} (${rs.length}ä»¶)`); }
      }
    }
  }
  camLoopHandle = requestAnimationFrame(camLoop);
}

renderModel(); renderCoverage();

el.toggleModel.addEventListener("click", () => {
  const show = (el.modelJson.style.display === "none");
  el.modelJson.style.display = show ? "block" : "none";
});
el.fileInput.addEventListener("change", async () => {
  const files = Array.from(el.fileInput.files || []);
  try {
    await handleFiles(files, InputSourceKind.image_file);
  } catch (e) {
    const msg = (e && e.message) ? e.message : String(e);
    log(`ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${msg}`);
  } finally {
    el.fileInput.value = "";
  }
});
const dirSupportMessage = document.getElementById("dirSupportMessage");
const supportsDirectoryUpload = "webkitdirectory" in document.createElement("input");
if (!supportsDirectoryUpload) {
  el.dirInput.disabled = true;
  if (dirSupportMessage) dirSupportMessage.textContent = "ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„ã€‚";
} else {
  if (dirSupportMessage) dirSupportMessage.textContent = "ãƒ•ã‚©ãƒ«ãƒ€é…ä¸‹ã®ç”»åƒã‚’ã¾ã¨ã‚ã¦å‡¦ç†ã—ã¾ã™ï¼ˆChrome / Edgeãªã©å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã®ã¿ï¼‰ã€‚";
}
el.dirInput.addEventListener("change", async () => {
  const files = Array.from(el.dirInput.files || []);
  try {
    await handleFiles(files, InputSourceKind.image_dir);
  } catch (e) {
    const msg = (e && e.message) ? e.message : String(e);
    log(`ç”»åƒãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${msg}`);
  } finally {
    el.dirInput.value = "";
  }
});
el.startCam.addEventListener("click", startCamera);
el.stopCam.addEventListener("click", stopCamera);

el.exportCsv.addEventListener("click", () => {
  if (records.length === 0) { log("CSVå‡ºåŠ›: ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒ0ä»¶ã§ã™"); return; }
  CSVWriter.download(records);
  log(`CSVå‡ºåŠ›: ${records.length} è¡Œ`);
});
el.clear.addEventListener("click", () => {
  stopCamera();
  records = [];
  seenPayloadKeys = new Set();
  renderTable();
  log("ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
});
</script>
</body>
</html>
