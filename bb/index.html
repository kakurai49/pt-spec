<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>動く仕様書：ボール反射 × きれいな音（Web版ゴールサンプル）</title>

  <!-- 添付CSS（pop3_style.css）を読み込み -->
  <link rel="stylesheet" href="pop3_style.css" />

  <!-- 追加CSS：このページのレイアウト/レスポンシブ/デモUI調整（添付CSSと共存） -->
  <style>
    /* 添付CSSの footer が fixed のため、本文が隠れないよう下余白を確保 */
    body { padding-bottom: 70px; }

    /* コンテナ内の2カラム配置（PC）→1カラム（スマホ） */
    .pageGrid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .pageGrid{ grid-template-columns: 1fr; }
    }

    /* 添付CSSの .character:hover が拡大するので、重なりを自然に */
    .character{ position: relative; transform-origin: center; }
    .character:hover{ z-index: 2; }
    /* タッチ端末では hover 拡大を無効化（ガタつき防止） */
    @media (hover: none){
      .character:hover{ transform: none; }
    }

    /* 上部の概要ブロック内のステータス表示 */
    .statusbar{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 10px;
      font-weight: bold;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display:inline-block;
      border: 2px solid #000;
      margin-right: 6px;
      vertical-align: middle;
      background: #ddd;
    }
    .dot.ok{ background: #4ade80; }
    .dot.warn{ background: #fbbf24; }
    .dot.bad{ background: #fb7185; }

    /* デモの正方形キャンバス枠 */
    .canvasFrame{
      width: min(640px, 100%);
      aspect-ratio: 1 / 1;
      background:#0a0f22;
      border: 4px solid #000;
      border-radius: 14px;
      overflow:hidden;
      position: relative;
      box-shadow: 6px 6px 0 rgba(0,0,0,.25);
      /* スマホでの操作性：キャンバス上のスクロール誤爆を防ぐ */
      touch-action: none;
    }
    canvas{ width:100%; height:100%; display:block; }

    .badge{
      position:absolute;
      left:10px; top:10px;
      background: rgba(255,255,255,.92);
      border: 2px solid #000;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      user-select: none;
    }

    /* デモ上部の見出し＋ボタン行 */
    .sectionHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }

    /* 操作UI：2列→スマホで1列 */
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 640px){
      .controls{ grid-template-columns: 1fr; }
    }

    .control label{
      display:block;
      font-weight: 800;
      margin: 0 0 6px;
    }

    /* ボタン/セレクト：Pop寄りの黒縁＋影（添付CSSには規定がないので追加） */
    button, select, input[type="range"]{ width:100%; }
    button, select{
      appearance: none;
      background: #fff;
      border: 3px solid #000;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 4px 4px 0 rgba(0,0,0,.25);
    }
    button.primary{
      background: #1e90ff;
      color: #fff;
    }
    button:active{
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 rgba(0,0,0,.25);
    }
    button:disabled{
      opacity: .6;
      cursor: not-allowed;
    }

    /* トグルUI */
    .toggle{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background: #fff;
      border: 3px solid #000;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 4px 4px 0 rgba(0,0,0,.18);
    }
    .toggle small{ display:block; opacity:.8; font-weight: normal; }
    .toggle input{ transform: scale(1.2); }

    /* 区切り線 */
    .hr{
      height: 2px;
      background: #000;
      opacity: .15;
      margin: 16px 0;
    }

    /* kbd風（元HTMLの仕様テキストに出てくる） */
    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border: 2px solid #000;
      border-radius: 10px;
      background: rgba(255,255,255,.75);
      font-size: 12px;
      font-weight: 900;
      margin: 0 2px;
    }

    /* 右カラムの見やすさ */
    .spec h3{ margin: 16px 0 8px; }
    .spec p, .spec li{ line-height: 1.7; }

    /* footer fixed 対応：スマホで少し小さく */
    @media (max-width: 640px){
      .footer{ font-size: 0.95rem; }
    }
  </style>
</head>

<body>
  <!-- 添付CSSの header スタイルをそのまま活用 -->
  <header>
    動く仕様書：ボール反射 × きれいな音（Web版ゴールサンプル）
  </header>

  <div class="container">
    <!-- ★元HTMLの「header内の説明文＋ステータス」も欠落させず、概要ブロックとして保持 -->
    <section class="character">
      <h2>概要</h2>
      <p>
        このページ自体が「仕様書」であり「ゴールサンプル」です。キャンバス内でボールが反射し、壁に当たった瞬間に音が鳴ります。
        音は Web Audio API（正弦波 + フェード + 倍音）で生成し、STEP を上げるほど“楽器寄り”の挙動になります。
      </p>

      <div class="statusbar" aria-live="polite">
        <span><span id="audioDot" class="dot warn"></span><span id="audioStatus">Audio: 未有効（クリックで有効化）</span></span>
        <span><span class="dot ok"></span>Animation: 常時動作</span>
      </div>
      <p style="margin-top:10px; font-weight:700;">
        ※スマホではキャンバスをタップしても Audio を有効化できます（ブラウザの自動再生制限対策）。
      </p>
    </section>

    <div class="pageGrid">
      <!-- Left: Demo（元HTMLの内容を欠落なしで保持） -->
      <section class="character">
        <div class="sectionHead">
          <h2>デモ</h2>
          <div class="actions">
            <button id="btnEnableAudio" class="primary" style="width:auto; min-width: 180px;">Audio を有効化</button>
            <button id="btnReset" style="width:auto; min-width: 120px;">リセット</button>
          </div>
        </div>

        <div class="canvasFrame" id="frame" aria-label="bouncing balls demo">
          <div class="badge" id="badgeText">STEP 1 / 壁で音程変化</div>
          <canvas id="c"></canvas>
        </div>

        <div class="controls">
          <div class="control">
            <label for="stepSel">STEP（仕様の段階）</label>
            <select id="stepSel">
              <option value="1">STEP 1：壁ごとに音程（最小）</option>
              <option value="2">STEP 2：3ボール（C-E-G）＝和音ポリリズム</option>
              <option value="3">STEP 3：マウス位置 + 速度で音程変化（表情）</option>
              <option value="4">STEP 4：Cメジャーへ量子化（さらに楽器寄り）</option>
            </select>
          </div>

          <div class="toggle">
            <div>
              <div style="font-weight:900;">ミュート</div>
              <small>音を鳴らさず動作確認したい場合</small>
            </div>
            <input id="muteChk" type="checkbox" />
          </div>

          <div class="toggle">
            <div>
              <div style="font-weight:900;">倍音ミックス</div>
              <small>2倍音・3倍音を少し混ぜて“芯”を出す</small>
            </div>
            <input id="harmChk" type="checkbox" checked />
          </div>

          <div class="control">
            <label for="volRange">音量</label>
            <input id="volRange" type="range" min="0" max="0.6" step="0.01" value="0.22" />
          </div>

          <div class="control">
            <label for="coolRange">衝突クールダウン（秒）</label>
            <input id="coolRange" type="range" min="0" max="0.10" step="0.005" value="0.03" />
          </div>
        </div>

        <div class="hr"></div>

        <div class="spec">
          <h3>使い方（この仕様書の読み方）</h3>
          <ul>
            <li>ブラウザでこのHTMLを開く</li>
            <li><span class="kbd">Audio を有効化</span> をクリック（ブラウザの自動再生制限対策）</li>
            <li>STEPを選ぶと、仕様どおりに挙動が変わる（＝仕様の確認になる）</li>
            <li>STEP 3 以降：マウスを左右に動かすと音程が変化</li>
          </ul>

          <h3>仕様概要</h3>
          <p>
            「壁で反射するボール」と「衝突音」を結び付け、段階的に“楽器寄り”へ拡張できるゴールサンプル。
            Python版へ移植する際も、同じ関数構造（反射/衝突→音程決定→発音）で再現できる。
          </p>

          <h3>STEP別の要件（受け入れ条件）</h3>
          <ul>
            <li><b>STEP 1</b>：ボールは枠内で反射し続ける。壁（左/右/上/下）で音程（半音オフセット）が変わる。</li>
            <li><b>STEP 2</b>：ボールを3個に増やす（C-E-G）。それぞれ周期が異なるため、自然にポリリズムになる。</li>
            <li><b>STEP 3</b>：音程決定に「マウス位置」と「速度」を加算し、表情を出す。</li>
            <li><b>STEP 4</b>：最終音程を Cメジャースケールへ量子化し、外れ音を減らし楽器っぽくする。</li>
          </ul>

          <h3>音響仕様（きれいな音のための最低要件）</h3>
          <ul>
            <li>波形：正弦波（基本波）</li>
            <li>クリック防止：Attack/Release（フェード）を必ず付ける</li>
            <li>倍音：2倍音・3倍音を少量混ぜられる（トグル）</li>
            <li>同時発音：衝突が重なっても鳴る（簡易ポリフォニー）</li>
          </ul>

          <h3>移植のための「関数分割」見取り図（このページの内部設計）</h3>
          <pre>
bounce(ball) -> hitWall?
  -> decideFreq(ball, wall, step, mouseX, speed)
     -> (optional) quantizeToMajor(freq)
  -> synth.play(freq, envelope, harmonics)</pre>
        </div>
      </section>

      <!-- Right: Spec (more structured)（元HTMLの内容を欠落なしで保持） -->
      <aside class="character spec">
        <h2>仕様（詳細）</h2>

        <h3>画面仕様</h3>
        <ul>
          <li>中央に正方形キャンバス（枠線付き）</li>
          <li>ボールは枠内で常時移動（停止しない）</li>
          <li>STEP・ミュート・倍音・音量・クールダウンをUIで切替可能</li>
        </ul>

        <h3>反射仕様</h3>
        <ul>
          <li>壁接触時：座標を壁境界に補正してから速度符号を反転（めり込み防止）</li>
          <li>フレーム：requestAnimationFrame で更新（約60fps）</li>
        </ul>

        <h3>衝突→発音の仕様</h3>
        <ul>
          <li>衝突イベント発生時のみ発音</li>
          <li>クールダウン：衝突音が連打されすぎないよう最小間隔を持つ</li>
          <li>壁別：左/右/上/下で音程の半音オフセットを変える</li>
        </ul>

        <h3>ポリリズムとは</h3>
        <p>
          速さ（周期）の違う複数のリズムが同時に鳴ること。ボールが複数で速度が違うと、
          「壁に当たるタイミング（リズム）」がズレて重なり、自然にポリリズムになる。
        </p>

        <h3>操作</h3>
        <ul>
          <li><span class="kbd">Audio を有効化</span>：音を鳴らすために必須（ブラウザ制限）</li>
          <li><span class="kbd">リセット</span>：ボール配置と速度を初期化</li>
          <li>マウス移動：STEP 3 以降で音程に反映</li>
        </ul>

        <h3>非目標（このサンプルではやらない）</h3>
        <ul>
          <li>リアルな物理（摩擦・回転・重力など）</li>
          <li>高品質リバーブ等の重いエフェクト（次拡張で可）</li>
        </ul>
      </aside>
    </div>
  </div>

  <div class="footer">
    © 動く仕様書サンプル（pop3_style.css 対応）
  </div>

<script>
(() => {
  // =========================
  // Utilities
  // =========================
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const semiToRatio = (semi) => Math.pow(2, semi / 12);
  const nowSec = () => performance.now() / 1000;

  // =========================
  // Canvas setup (HiDPI)
  // =========================
  const frame = document.getElementById("frame");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = frame.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    // 描画はCSSピクセル基準にスケール
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // =========================
  // UI Elements
  // =========================
  const stepSel = document.getElementById("stepSel");
  const btnEnableAudio = document.getElementById("btnEnableAudio");
  const btnReset = document.getElementById("btnReset");
  const muteChk = document.getElementById("muteChk");
  const harmChk = document.getElementById("harmChk");
  const volRange = document.getElementById("volRange");
  const coolRange = document.getElementById("coolRange");
  const badgeText = document.getElementById("badgeText");
  const audioDot = document.getElementById("audioDot");
  const audioStatus = document.getElementById("audioStatus");

  // =========================
  // Audio (Web Audio API): Sine + Envelope + Harmonics
  // =========================
  let audioCtx = null;
  let masterGain = null;
  const activeVoices = [];
  const MAX_VOICES = 18;

  function setAudioStatus(state) {
    if (state === "ready") {
      audioDot.className = "dot ok";
      audioStatus.textContent = "Audio: 有効";
      btnEnableAudio.disabled = true;
    } else {
      audioDot.className = "dot warn";
      audioStatus.textContent = "Audio: 未有効（クリックで有効化）";
      btnEnableAudio.disabled = false;
    }
  }

  async function enableAudio() {
    if (audioCtx) {
      try { await audioCtx.resume(); } catch {}
      setAudioStatus("ready");
      return;
    }
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;
    masterGain.connect(audioCtx.destination);

    try { await audioCtx.resume(); } catch {}
    setAudioStatus("ready");
  }

  function playNote(freqHz, durationMs = 140) {
    if (muteChk.checked) return;
    if (!audioCtx || audioCtx.state !== "running") return;

    const volume = clamp(parseFloat(volRange.value || "0.22"), 0, 0.8);
    const useHarm = !!harmChk.checked;

    // Voice limiter
    while (activeVoices.length > MAX_VOICES) {
      const v = activeVoices.shift();
      try { v.stop(); } catch {}
    }

    const t0 = audioCtx.currentTime;
    const dur = clamp(durationMs / 1000, 0.05, 1.2);

    // Envelope (Attack/Release)
    const attack = 0.010;
    const release = 0.060;
    const t1 = t0 + attack;
    const t2 = t0 + Math.max(attack, dur - release);
    const t3 = t0 + dur;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, volume), t1);
    g.gain.setValueAtTime(Math.max(0.0002, volume), t2);
    g.gain.exponentialRampToValueAtTime(0.0001, t3);
    g.connect(masterGain);

    // Fundamental
    const o1 = audioCtx.createOscillator();
    o1.type = "sine";
    o1.frequency.setValueAtTime(freqHz, t0);

    const g1 = audioCtx.createGain();
    g1.gain.value = 1.0;
    o1.connect(g1).connect(g);

    // Harmonics (2x, 3x) tiny mix for "芯"
    let o2, o3, g2, g3;
    if (useHarm) {
      o2 = audioCtx.createOscillator(); o2.type = "sine"; o2.frequency.setValueAtTime(freqHz * 2, t0);
      o3 = audioCtx.createOscillator(); o3.type = "sine"; o3.frequency.setValueAtTime(freqHz * 3, t0);

      g2 = audioCtx.createGain(); g2.gain.value = 0.18;
      g3 = audioCtx.createGain(); g3.gain.value = 0.10;

      o2.connect(g2).connect(g);
      o3.connect(g3).connect(g);
    }

    const stopAll = () => {
      try { o1.stop(); } catch {}
      if (o2) try { o2.stop(); } catch {}
      if (o3) try { o3.stop(); } catch {}
      try { g.disconnect(); } catch {}
      try { g1.disconnect(); } catch {}
      if (g2) try { g2.disconnect(); } catch {}
      if (g3) try { g3.disconnect(); } catch {}
    };

    o1.start(t0);
    if (o2) o2.start(t0);
    if (o3) o3.start(t0);

    o1.stop(t3);
    if (o2) o2.stop(t3);
    if (o3) o3.stop(t3);

    // Cleanup later
    const voice = { stop: stopAll };
    activeVoices.push(voice);
    setTimeout(() => {
      const idx = activeVoices.indexOf(voice);
      if (idx >= 0) activeVoices.splice(idx, 1);
      stopAll();
    }, (dur + 0.1) * 1000);
  }

  // =========================
  // Spec/Behavior: Balls & Steps
  // =========================
  const BORDER = 6;
  let step = parseInt(stepSel.value, 10) || 1;

  const wallOffsets = { left: 0, right: 4, top: 7, bottom: 12 }; // semitones

  // Pointer/Mouse for STEP3+（レスポンシブ：スマホはpointerで追従）
  let mouseX = 0.5;
  let mouseY = 0.5;
  let pointerDown = false;

  function updatePointer(clientX, clientY){
    const r = frame.getBoundingClientRect();
    mouseX = clamp((clientX - r.left) / r.width, 0, 1);
    mouseY = clamp((clientY - r.top) / r.height, 0, 1);
  }

  frame.addEventListener("mousemove", (e) => updatePointer(e.clientX, e.clientY));
  frame.addEventListener("pointerdown", (e) => {
    pointerDown = true;
    try { frame.setPointerCapture(e.pointerId); } catch {}
    updatePointer(e.clientX, e.clientY);
    // キャンバスタップでも音を有効化（スマホ向け）
    if (!audioCtx || audioCtx.state !== "running") enableAudio();
  });
  frame.addEventListener("pointermove", (e) => {
    if (e.pointerType === "mouse" || pointerDown) updatePointer(e.clientX, e.clientY);
  });
  frame.addEventListener("pointerup", () => { pointerDown = false; });
  frame.addEventListener("pointercancel", () => { pointerDown = false; });

  function quantizeToCMajor(freq, root = 261.63) {
    // C major: 0,2,4,5,7,9,11
    const scale = [0,2,4,5,7,9,11];
    const semis = 12 * Math.log2(freq / root);
    const nearest = Math.round(semis);
    const octave = Math.floor(nearest / 12);
    const within = ((nearest % 12) + 12) % 12;

    let best = scale[0];
    let bestDist = Math.abs(scale[0] - within);
    for (const s of scale) {
      const d = Math.abs(s - within);
      if (d < bestDist) { best = s; bestDist = d; }
    }
    return root * semiToRatio(octave * 12 + best);
  }

  function pitchModFromMouse() {
    // x: -6..+6 semis
    return (mouseX * 12) - 6;
  }

  function pitchModFromSpeed(ball) {
    const speed = Math.hypot(ball.vx, ball.vy);
    return clamp((speed - 2.0) * 1.5, 0, 6); // 0..+6 semis
  }

  function decideFreq(ball, wall) {
    let semis = wallOffsets[wall] ?? 0;

    if (step >= 3) {
      semis += pitchModFromMouse();
      semis += pitchModFromSpeed(ball);
    }

    let freq = ball.baseFreq * semiToRatio(semis);

    if (step >= 4) {
      freq = quantizeToCMajor(freq, 261.63);
    }
    return clamp(freq, 60, 2000);
  }

  function badgeForStep(s) {
    if (s === 1) return "STEP 1 / 壁で音程変化";
    if (s === 2) return "STEP 2 / 3ボール（C-E-G）＝和音ポリリズム";
    if (s === 3) return "STEP 3 / マウス+速度で音程（表情）";
    return "STEP 4 / Cメジャー量子化（楽器寄り）";
  }

  function makeBallsForStep(s, W, H) {
    const left = BORDER, top = BORDER, right = W - BORDER, bottom = H - BORDER;

    const cx = (left + right) / 2;
    const cy = (top + bottom) / 2;

    if (s === 1) {
      return [
        { x: cx - 140, y: cy - 40, vx: 3.6, vy: 2.7, r: 14, color: "#1f6feb", baseFreq: 261.63, lastHit: 0 }, // C4
      ];
    }
    return [
      { x: cx - 170, y: cy - 50, vx: 3.6,  vy: 2.1,  r: 14, color: "#1f6feb", baseFreq: 261.63, lastHit: 0 }, // C4
      { x: cx + 120, y: cy + 60, vx: -2.7, vy: 3.9,  r: 14, color: "#2da44e", baseFreq: 329.63, lastHit: 0 }, // E4
      { x: cx + 10,  y: cy - 140, vx: 4.2,  vy: -2.8, r: 14, color: "#bf8700", baseFreq: 392.00, lastHit: 0 }, // G4
    ];
  }

  let balls = [];
  let lastFrameT = 0;

  function reset() {
    resizeCanvas();
    const rect = frame.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;
    balls = makeBallsForStep(step, W, H);
    badgeText.textContent = badgeForStep(step);
  }

  function bounceAndGetHit(ball, W, H) {
    const left = BORDER;
    const top = BORDER;
    const right = W - BORDER;
    const bottom = H - BORDER;

    ball.x += ball.vx;
    ball.y += ball.vy;

    let hit = null;

    if (ball.x - ball.r <= left) {
      ball.x = left + ball.r;
      ball.vx *= -1;
      hit = "left";
    } else if (ball.x + ball.r >= right) {
      ball.x = right - ball.r;
      ball.vx *= -1;
      hit = "right";
    }

    if (ball.y - ball.r <= top) {
      ball.y = top + ball.r;
      ball.vy *= -1;
      hit = hit ?? "top";
    } else if (ball.y + ball.r >= bottom) {
      ball.y = bottom - ball.r;
      ball.vy *= -1;
      hit = hit ?? "bottom";
    }

    return hit;
  }

  function maybePlayHit(ball, wall) {
    const cooldown = clamp(parseFloat(coolRange.value || "0.03"), 0, 0.2);
    const t = nowSec();
    if (t - (ball.lastHit || 0) < cooldown) return;
    ball.lastHit = t;

    const freq = decideFreq(ball, wall);
    const dur = (step <= 2) ? 110 : 140;
    playNote(freq, dur);
  }

  function draw(W, H) {
    ctx.clearRect(0, 0, W, H);

    // Frame border (drawn inside)
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = BORDER;
    ctx.strokeRect(BORDER/2, BORDER/2, W - BORDER, H - BORDER);
    ctx.restore();

    // Balls
    for (const b of balls) {
      // Shadow
      ctx.beginPath();
      ctx.arc(b.x + 7, b.y + 9, b.r * 0.95, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fill();

      // Body
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.color;
      ctx.fill();

      // Highlight
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.35, b.y - b.r*0.35, b.r*0.35, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.fill();
    }

    // STEP3+ hint: show mouse line lightly
    if (step >= 3) {
      ctx.save();
      ctx.strokeStyle = "rgba(122,162,255,0.20)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(mouseX * W, 0);
      ctx.lineTo(mouseX * W, H);
      ctx.stroke();
      ctx.restore();
    }
  }

  function animate(t) {
    resizeCanvas();
    const rect = frame.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    const dt = lastFrameT ? (t - lastFrameT) / 1000 : (1/60);
    lastFrameT = t;

    for (const b of balls) {
      const wall = bounceAndGetHit(b, W, H);
      if (wall) maybePlayHit(b, wall);
    }

    draw(W, H);
    requestAnimationFrame(animate);
  }

  // =========================
  // Wire up UI
  // =========================
  btnEnableAudio.addEventListener("click", enableAudio);
  btnReset.addEventListener("click", reset);

  stepSel.addEventListener("change", () => {
    step = parseInt(stepSel.value, 10) || 1;
    reset();
  });

  // On load
  setAudioStatus("off");
  window.addEventListener("resize", reset);
  reset();
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>
